Course Overview
Hi everyone. My name is Justin Boyer, and welcome to my course, Understanding OAuth with Node.js. If you've ever used the Log in with Google button on a website, you've used OAuth, but how would a business-to-business application work with OAuth? In this course, we're going to build a realistic business application that uses OAuth to share data. We'll be using a scenario that will become more likely as OAuth adoption increases. Some of the major topics that we will cover include how an OAuth application functions under the hood; how to build an OAuth client, protected resource, and authorization server in Node.js ; and what security vulnerabilities might arise and how to fix them. By the end of this course, you'll be able to build OAuth functionality into your existing Node.js application or build an OAuth ready web service from scratch. Before beginning the course, you should be familiar with the OAuth 2.0 protocol. You should also know how to build a Node.js web application using Express.js. I hope you'll join me on this journey and learn how to share data between web services with the understanding OAuth and Node.js course at Pluralsight.

OAuth 2.0 in Action
Introduction
Hey, this is Justin Boyer, and this is Understanding OAuth in Node.js. Thanks so much for watching this course. I am the owner of Green Machine Security, and we're going to take you through implementing OAuth in Node.js using a real-world example. This is going to be a streamlined practical training that will get you started with OAuth. We're not going to dive into every single little detail, but we will get you started and get you enough of a good enough foundation of where you can continue your studies. So in the end, we will have a fully working operational OAuth application, an OAuth protected API, and we will see how all of that works in just a second. But first, let's talk about the scenario we're using, the real-life scenario that we're using to illustrate these concepts. So Globomantics' HR has a new initiative, so we're going to pretend that we're the Globomantics employees working with another company that we will reveal in a second to create an OAuth application. Globomantics HR wants to save on healthcare, and they came up with an interesting idea. There is a company called Carved Rock Fitness, and they are a fitness company and a gym, and so Globomantics has decided to start a partnership with Carved Rock Fitness, and that means we can share information. What the HR department wants is your information. So as an employee of Globomantics, you can authorize them to pull out different datapoints from the gym and then use that to get credits and discounts on your healthcare. Globomantics saves money by having healthier employees, and employees save money as well. What do we need to have this type of system work? Well, we need Globomantics' systems to communicate with Carved Rock, so we need to find a good protocol that will allow easy communication between two different company's systems. You may already have an idea of what that is. We'll talk about that in a second. We also need the data to be transferred in a secure manner, we can't just have it floating around on the internet for anybody to grab, and we also need to have the employees give permission. Permission is a big deal, especially in today's age of privacy concerns. It's important for the employees to give explicit permission for Carved Rock Fitness to share their information with Globomantics, and we need a system that will allow employees to do that. So what is that system? Well, you may not be surprised that it's OAuth because that's what this course is about, but OAuth is the perfect solution for this kind of scenario because for the communication, it works very, very well with HTTP and HTTPS, so we have that communication protocol, and as far as secure, it's also HTTPS friendly, and it requires authentication to use and uses very solid security practices in order to keep your data secure, and we'll talk about some of that, and then the permission. This is the big piece. OAuth as a protocol is an authorization protocol. It allows a person to give an application permission to access another app on their behalf, so the users control exactly what to share with whom. So that's how OAuth is the best option for us. Now we're going to take a look at a sample application that I've built, and then we'll dig into how that sample application works. First, let's just do a high-level overview of how it works, and then we'll view how it actually works in a demo.

How the Finished Application Works
We want to take a look now at how our application works, so this is going to follow the normal workflow of an OAuth application. And if you are not yet familiar with OAuth as a protocol, about how it works, and how to implement it at a high level, check out the Getting Started with OAuth 2.0 Pluralsight course. So I'm going to assume going forward that you viewed that course and you understand how OAuth works and that you understand some of these terms such as the resource owner, the client, the authorization server, and a protected resource. So let's move into how our specific application will work. We have a Globomantics client. That's the HR application that wants the data from Carved Rock. The Globomantics employee is the resource owner. Now our first step is the Globomantics client app will redirect our user to the Carved Rock Fitness authorization server. The employee will authenticate to Carved Rock Fitness and authorize the Globomantics app to receive their data, so this is the important part of authorization where the employee authenticates and also proves who they are and then tells Carved Rock that Globomantics is allowed to see their data. In our specific application, we're not going to be talking about specific ways to authenticate because that is actually dependent on Carved Rock themselves. In a real-world application where we are the Globomantics client, we don't care how they authenticate, and we're not worried about that. Another option that we could have is a single sign-on solution where maybe we pass some SAML or something that proves who we are and who the employee is, but that is out of the scope of this course. So when we look at our application, we'll see that there isn't going to be a log-in page. It's just going to assume that the authentication already happened. Once we have that authorization, the authorization server redirects the employee back to the client with an authorization code, and that authorization code is how the client then asks for a token from the authorization server, so we're going to connect to the token endpoint, and then the client authenticates using its own credentials, and we'll speak about how that is done and ways you can protect those credentials. Once the client is authenticated and authorization server knows who the client is, we're then going to send that token back as long as it's a valid authorization code. And once the client has that token, that's what it'll use the access the employee's workout data from Carved Rock Fitness's database. So it will send the token, and the protected resource will have the job of making sure that that token is valid and then returning the information based on what's in the token. These are the pieces that we're going to deep dive into. We're going to see how the client is actually written in Node.js, we're going to see how to process these authorization codes and tokens, what the tokens actually look like, what they're made of, and all sorts of information about security and making sure that each endpoint is secure. But first, we're going to take a look at the application in action.

Reviewing the Finished Code
Let's take a look at the application. We're going to take a look at the final application as it works, and then we're going to take a look at the flow from the employee's viewpoint, so we want to see and walk through how the OAuth transaction is going to happen. Finally, we're going to take a look at the network request and the HTTP requests to find out exactly what's happening under the hood, and it'll give you an idea of kind of the mechanisms in place and how OAuth will work overall. So we're going to go over to Chrome now, and to start off, I want to show you how to start up this application so that when you get the downloaded code, you can work it too. What you see in front of you are three windows, PowerShell windows, and there are three files. One is the Globomantics client, the other is the protected resource on the Carved Rock side, and we also have the authorization server for Carved Rock, and we have these areas, these three pieces in the same project just for simplicity. These would not be in the same project in a real-life scenario. Globomantics would have its code base separate from Carved Rock, but this is just to keep things simple. And how you would do it is you would open up three different terminals or PowerShell windows as I've done and run each of these applications in their own terminal window. All three have different ports, and they're all running at the same time right now. And this is how you can run it when you download the code example yourself. Alright, so we've gone to the incognito window just to make sure that there's no caching windows, and we're going to go to localhost:9000, and localhost:9000 is the client, so this is the Globomantics client. There's a little bit of branding here and all sorts of good stuff. But what I want to focus on is the center section here, and this will help you to see the flow of the application. Again, this is now about the UI design or anything like that. This is just to get you to understand the functionality that Node.js has in this regard. So we have the access token value, the scope value, and the refresh token value here, and what we're going to do is get the OAuth token. What this means is we'll go to the authorization server and get our authorization code and then use that to gain a token. So I'm going to I click this button, and I'm going to open up the network here so that you can see exactly what's happening on the Network tab, and I hit this button here. Now before we look at the page itself, let's take a look at what actually happened. We went to a /authorize on localhost:9000, and that gave us a 302 status. Well, 302 is a redirect. We redirected, as you can see, to this URL, so we have localhost:9003. That was our authorization server address. We have an authorization endpoint there at /authorize, and the key for OAuth in the beginning here is this URL and what happens afterwards, these parameters. We have the response_type=code. That means we're using the authorization code grant type. There are other grant types. For instance, if we were using the refresh token to get a new authorization code, we would have the response_type equal to refresh token, and there are other different types we could use. For us, we're using the authorization code grant type because it operates on, it kind of gives us the complete picture of the entire OAuth workflow, and then there are other grant types, such as the implicit grant types for browser-based applications and others that may skip some steps or maybe are optimized for specific scenarios. But if you understand the authorization code grant type, then you will understand all the other ones because the other ones are much simpler, and this one will show you all the different pieces so that you're better able to handle the rest. The scope parameter here is the scope that we're asking for as a client. We're asking for visits, for membership time, for average workout length. This is basically the data that we want from Carved Rock, and it is in a space-separated, or a space-delimited, string. It's space delimited so that it can be sent through URLs more easily, and then would be parsed on the server side and validated, which we'll see when we look at the code. After that, we have a client_id. The client_id is the id of the client, and it's a way for the client to introduce itself and to say hi, I'm the Globomantics client. This could be Globomantics HR or whatever you want. It doesn't matter. But at the end of the day, it's saying, hi, I'm Globomantics, and I would like these scopes, please, and when you give me those scopes after you authorize or authenticate the user, send it back to this redirect_uri, and that's the final argument there, the redirect_uri, which is the callback function that we want to be called. In our case, it's localhost:9000, which is the client/callback. Finally, we have a state parameter. So this state parameter is very important for security reasons. It prevents cross-site request forgery by creating a random value on every request, and we'll take a closer look at it when we talk about client vulnerabilities in our client module. But a state value is sent to the authorization server, and according to the OAuth spec, it must be sent back if it's sent. So it is optional, but it's always a best practice because of the CSRF vulnerability. And if the authorization server gets this, it must send it back, and we'll see that in a second. Now as far as the page goes, we see here that Carved Rock is going to be asking the user, hey, do you want to approve this client? Again, this is where the ID may be a name or something like that, so it's easy to understand. And we have the Redirect To here as well. You can see what that URL is. You wouldn't necessarily show that to the end user. This is for our purposes. But we see that we have this client. Hey, do you want to approve this client? It's Globomantics. And it says that the client is requesting access to the following, and this is our list of, this is our scope. So our scope was parsed and then passed into this page, and that gives us, as the user, I can come in here, and I can actually tell them, no, I don't want them to have visits or membership time, only my average workout length, or yeah, fine, it's okay to have all three. This is where the user is giving the permission, the explicit permission, for Globomantics to access this information. You may be asking at this point why we didn't authenticate, why there was no log-in page or anything, and the reason is that OAuth is not an authentication mechanism. It is an authorization mechanism. The authentication is out of scope for what OAuth is doing. In this scenario, there are a couple of options. One could be Carved Rock has a page and its own authentication database and therefore would just create a page that the user would log into, and then this page would come after that page. Another option, because these are two companies working together, could be a SAML assertion or something like that. OAuth 2 does give you an option to have an assertion-based grant type, which means you can use a SAML assertion or some other single sign-on method in order to grant access to the application in order to authenticate the user up front. So at this point, we're assuming, like in a production application, to reach this point, you would authenticate the user on the Carved Rock side. So the employee would log into Carved Rock Fitness, prove who they are by username, password, 2FA, whatever you have, and then they would be taken to this page, and this page is where it says, okay, I know who you are, and I also know who this client is. This client is requesting access. Are they allowed to access this data or not? So I'm going to hit Approve, and we'll see what happens. Before we look at that page, let's look at the code. We see here the request was made to 9003/approve, which is the authorization server, and then once again, we are getting a 302 or redirect. And where is that redirect going? The redirect is going back to the client to that redirect URI. The redirect URI is lcoalhost:9000/callback, and the code here is sent back. This is the authorization code. This is the code that the client can then use to receive a token. And in the end, you see that same state value. Like I said, the OAuth spec says that the authorization server, if it receives a state, must send that same state back, and the client can then use that state to verify that the request has not been tampered with and that it hasn't been faked. It's a way to prevent cross-site request forgery. So we have this code, but this code, something happened with this behind the scenes. We can't see it because it's not a front-channel mechanism, meaning it's not happening in the browser. Up to this point, we've been doing front-channel communication, which means redirecting the browser URL. We didn't do that this time. We redirected to /callback, and I'll show you in the code, but callback has already used that authorization code in order to receive a token. So then it populates the page with that token, so let's take a look at that. Here's our token, and it's a very, very, very long token here. It doesn't fit very well. But the idea of this token is it's a JSON web token, and we'll talk about that a little bit more as we move through the course, but a JSON web token that is actually cryptographically signed, and we'll talk about how that works once we get into the individual components. We also have the Scope value here, so this is the scope that we received, this is what the client has authorized us for, and then we have a refresh token, and the refresh token can be used to get a new access token if this access token expires. So now, we have all this data. We have a JSON web token that is telling the protected resource what we're allowed to have. So let's now get the protected resource. I'm going to click on this Get Gym Stats. We can see in the bottom-left corner, it's going to go to the client /gymStats. This is, again, going to be a back-channel communication. So what's going to happen is it's going to that page, and then the code and the client will reach out behind the scenes and grab the data from the protected resource, which is the gymStats, and when that happens, you see here is our data. We have the scope here, again, the same scope, and we are making decisions in the protected resource based on that scope, as you'll see in the code, and then we can actually see the number of visits, 120 visits in the last year. We have 2 years of membership, and an hour and a half is the average length of our workouts. In the production application, we will be making decisions based on these stats. We would have a calculation table that says if you have reached this number of visits, you maybe get this many credits, the user membership, all that stuff. So that's up to Globomantics and the HR system itself to make decisions based on this data. What I've showed you here is the mechanism by which we get that data. We are authenticating the end users, the end user authorizes Globomantics to then reach out to Carved Rock Fitness and get this data. So that's our working application. We're going to go into the next module, and that's going to talk about the, we're going to break down each individual piece of this application and look at the code and how it all works, but now you have an idea of what this application is doing. And before we hop into those next few modules though, let's review this module.

Summary
Alright, so let's summarize what we've talked about in this module. We have a new HR initiative from Globomantics, and we're in charge of implementing the application that will make it happen. The application that's required will use Carved Rock Fitness data to give discounts to employees. So what we're going to talk about is the actual implementation of the OAuth piece of that, so we're not going to go outside of that piece, we're not going to go into details that just aren't specifically around OAuth. We're going to see how to authenticate, authorize, and get the token. So they're going to need three things. We're going to need communication, we're going to need security, and we're going to need employee permissions. So we know that OAuth is the best option for this. Communication is over HTTP, for security, we can communicate over HTTPS, and for employee permissions, we have the OAuth protocol, which OAuth is all about giving permissions for applications to work on your behalf. So in our case, the employees will authorize the Globomantics use of the data and get healthcare discounts based on their workout times. Again, this is an opt-in, so OAuth is perfect for this case because of the fact that they are opting in, the employees don't have to do this, but they can, and once they authorize to Carved Rock, they are giving Globomantics specific and explicit permissions on what they're allowed to see. And so similar apps may be needed by your company. That's why this is so important. Because as we move forward in the evermore interconnected age that we're in, these types of things will come up within your career. You're going to need a lightweight protocol that allows you to share data between companies, there is joint ventures, there is these types of applications that pop up, especially in the enterprise world, and having the knowledge of how to implement OAuth in Node.js and which situations make sense for it will serve you so well as you go forward in your development career. So first, we're going to take a look at the client up next in the next module, and we're going to see how that client works. We're going to look at the actual code that implements the client, and we're going to learn a whole lot about the client, the code, and any security vulnerabilities that they have. So I'll see you in the next module, and I can't wait to see you then. Goodbye.

Building the OAuth Client
Introduction
Hi, this is Justin Boyer, and welcome back to OAuth in Node.js. In this module, we're going to be talking about the OAuth client and how to build that in Node.js. To start off, we're going to talk about the client's specific role in our application. The client's role is twofold, first to ask for permission. The client will redirect the resource owner to the authorization server to ask permission to access the resources it needs. Once it gets permission, the client accesses the protected resource on behalf of the resource owner. What this means is that the user is not needed once the permission is given. The apps can talk to each other freely. Let's see what this looks like in our diagram. If you remember our diagram from the last module, this will highlight exactly where the client fits in. The client redirects the user, the employee then authenticates, gives Globomantics the ability to read Carved Rock Fitness's database. The client then sends an authorization code to the authorization server and to its token endpoint, and then the token comes back, and the client then reaches the protected resource using the token, so three places there redirecting the owner, then reaching out to grab the token from the authorization server, and then using the token to access the protected resource. Alright, so time to dive into some code. Let's take a look at what this actually all looks like in Node.

Reviewing the Client Code
Hey, this is Justin Boyer. Welcome back to Understanding OAuth in Node.js. We're going to take a look at the Globomantics client code, and we're going to go over all the key pieces that touch on the OAuth functionality. We're going to be using Express.js to build our server, but I'm not going to go over the setup code. We'll just touch on the OAuth specific things. First up, we have the authServer, so these are the endpoints that we have, our authorizationEndpoint and our tokenEndpoint. Next up, we have a key. This is actually a public key from the authorization server so that the authorization server can sign the tokens, and we'll know that they came from the authServer we think they came from. We'll take a look at what that looks like in a second. Here, we have the client information, and this is actually our first decision point. We have two ways that we can register our client. We can either do a static registration or a dynamic registration. So a dynamic registration is when a client at runtime goes to the authorization server and says, hey, I'm a new client, register me, please, let's figure out a secret together, all that kind of stuff is figured out at runtime. Static registration is when ahead of time the client is known to the authorization server and there's a shared secret between them. To keep thing simple, we've stored the secret right here in the code. We would never do that in production. We would add it to a credential store, like Vault, so that we can grab it at runtime when we need it. We have our redirect_uris, which are the URIs we want the authorization server to redirect back to. You can have multiple. In this case, we have one. And our scope, which is, these are the scopes that the client couple possible get access to. This is not the final list. That's up to the resource owner to decide. Next, we have the carvedRockGymApi, so this is basically just a variable holding where the API is that we want to eventually access. And when we come down here, this is our first piece. When you click the Get OAuth Token button, it's going to send you to /authorize. This is our authorization endpoint from the client side, and what this is going to do is it's going to wipe out all of the access_tokens, refresh_tokens, and scope that we have and create a random state. Then the authorizeUrl is built by using the authorizationEndpoint and then adding the response_type, the scope, the client_id, the redirect_uri, and the state. Do you remember this URL from our time looking at the code in the browser? Well, guess what? This is how that URL is built, and now you can see what it looks like in the end. Then we do our redirect to the authorizeUrl, which is that 302 code you saw. And once the user clicks Approve for the scope that they want the client to have access to, we will then call the callback from the authorizationServer. So once the authorizationServer redirects to the callback, we're going to hit this callback function. First, we're going to check to see if there's an error within the query. The authorizationServer may return an error, and in this case, we will simply render that error. Once we have the state, we will pull it from the query, and we'll also check to make sure it's equal to the state that we created before. This is important because the OAuth spec says that if a state is added to a query parameter, then the authorization server has to return that same state, and this is a protection against cross-site request forgery. If this state is different, then you should throw an error because something bad is happening, either there is a major error or somebody is trying to attack the application. Next, we're going to take the authorization_code from the query parameters, and we're going to add it to some form data. The form data holds the grant_type, which in our case is authorization_code. Then we have the authorization code in there, and then we have the redirect_uri. Now this is important because the redirect_uri will be validated on your authorization server as the same one we used before just to make sure, again, that it's talking to the same client that it talked to before and to make sure there is nothing bad happening here. We then have to authenticate our client to the authorization endpoint to prove that we are who we say we are. In this case, we're using an Authorization header with HTTP Basic auth. So normally, this would be over TLS connections, so this would all be encrypted, and we are just creating our Base64 encoded string here of the client_id followed by a colon followed by the client_secret. Once that's done, we're doing a POST request. Now this is happening in the background. This is a back-channel request. The user is not seeing it, and the browser is not seeing it. We're going to take that POST request. It's going to return to us a chunk of JSON, so we're going to parse the JSON, and we're going to grab the token out of it. And once we have the token, we're going to see if there's a refresh_token and grab that as well. Up next, we're going to validate the token to make sure that all of the fields are correct and that it's a valid token. We're doing this using a library called JS RSA Token, and we're using it to use our rsaKey, the public key that we have, in order to verify that it's coming from the authorization server we expect it. First, we check this issuer, so we're checking to make sure that it is coming from the authorization server at port 9003. Then we check the Audience here, and that's making sure that it's ultimately going to be going to the protected resource that we have. Then we are making sure that it was issued at a time that was earlier than now and also that its expiration is later than now. And then if any of these checks don't work, then we're rendering in an error page. And you could also do a refresh access token call here and refresh the access token and check it again, but I'll leave that as an exercise for you. Up next, we have a helper function, and this helper function is refreshing the access_token. So if the access_token was expired or didn't work for some reason, we can refresh the token with our refresh_token. What that means is we'll get a brand-new access token without having the user click the Approve button again. The user is left out of it, and it gives us a change to get a new fresh token. Next up is when we go to get our gymStats. So this is actually using our token to grab the data we need. If there's no access token, we simply refresh the access_token again; otherwise, if we don't have a refresh_token either, we just have an error. And then we create new headers. Notice the Authorization header in this point. It's the Bearer method, so we're using a Bearer token, so it's Bearer, space, and then the access_token we have. When we are using Authorization this time, it's with the Bearer token. It's not with any credentials at all. The token is our credential. Now we request the data from the API, and this is just a simple GET request, again, happening in the background. Once we see that that comes back successful, we parse the JSON that comes back and we render the view with the data that comes back. This is that view where we see how many hour we spent at the gym, how long we've been a member of the gym, what's our average workout length, those pieces of data come from this call where we're using the token, and the protected resource is returning a chunk of JSON based on the scope that we've been authorized for by the resource owner. And that is pretty much it. As far as the client goes, those are the main functions. You're going to redirect the user to the authorization server, get an authorization code, and then use that authorization code to get a token, and once we know that that token is valid, then we use it to get the data we need. So now that you've seen the code and understand how it works, let's now take a look at some of the common client vulnerabilities you'll find and how to protect yourself against them.

Common OAuth Client Vulnerabilities
Let's now take a look at some of the common security vulnerabilities you'll find with OAuth clients and how to fix them. First off is cross-site request forgery. We spoke about cross-site request forgery a little bit when we were talking about the code. This is where a malicious application forges a request to a website where the user is authenticated. In the context of OAuth, an attacker can receive or forge an authorization code, and then they could trick the victim's browser into sending it to the client's callback URI. This could happen via an image source or perhaps somebody clicks a link in an email. The fix for this, as recommended by the OAuth standard, is to use a state parameter. So the state parameter is just a random value that you add to every OAuth transaction, and the authorization server saves it, client saves it, and then both of them know that it's the same request and that nothing has been tampered with because that value matches. So you saw that in the client code where the state came back to use from the authorization server, and we made sure it was the same state that we started with. And if that's not the case, you're probably under attack or a major issue is happening. Another way that clients can be vulnerable is by the theft of the client credentials. So in our case, we're using static registration, and fully protected credentials can be stolen by an attacker. So again, we keep the credentials secure with a credential management system. For example, we don't keep the credentials in the code, which could then be placed into a GitHub repository or perhaps stolen in some other way. With a credential management system, like Vault, we can get the credentials at runtime when we need them. Another way to fix this is to use dynamic client registration because dynamic registration doesn't require that we have a shared secret between the authorization server and the client that could be then stored and stolen. Another vulnerability is the incorrect registration of the redirect URI. So what do I mean by this? Well, your redirect URI must be as specific as possible. Sometimes, you may use only a domain and then validate based on whether the domain is in the URL that's passed in, regardless of what comes after. That opens up your client foreign attack. One way is by stealing your authorization code from a referrer header. As you've seen, the OAuth flow includes many redirects back and forth through the browser with URLs. When those redirects happen, there is going to be a referrer header, and it's going to look like this. So that referrer header will have the authorization code in there. Once the attacker has that authorization code and things are not done properly on the authorization server side, they could use that to get a token. They could also steal the token through an open redirect. The authorization server could validate your domain, and instead of the actual redirect URI the client wants, or if the client is using an open redirector, then they could pass in their own URL to their malicious site and then attack the token to the end of that. That token will be passed through to their malicious site, they'll be able to steal the token and use it to grab the data. In general, even _____ on its top 10, open redirects are generally a very bad idea. And in OAuth, open redirects are very, very bad. In other applications, you may be able to get away with it without much damage. In OAuth, that's not the case. It's very dangerous to have an open redirect where you're not validating the URL before redirecting. So the fix for this is to use exact match only to validate your redirect URIs. For example, you should not have your redirect URI say youroauthclient.com, and then if somebody passes in youroauthclient.com /redirector? goto= websitethatsevil.com, you see how that would actually be very bad. The authorization server would say, well, it's part of youroathclient.com, but what's going to happen in the browser is a redirect to a malicious website, so an attacker could send that in an email, have you click on it, and then steal your data. What you want is something like this, very, very specific, youroathclient.com /oath/oathprovider/callback, very, very, very, specific. And when you validate, it has to have that. If somebody sends in youroathclient.com, it does not validate. It only validates if it has all of those paths and everything exactly the same. And now, the worst practice, which is placing a token in the URL parameter. This is a very, very bad practice because even though OAuth allows tokens to be placed in the URL parameter, it's only a last resort, and the spec even makes that clear. It's only as a last resort because it's very, very unsecure to do this, but there are some applications where you just have to. They build it into the spec. But if you don't have to, please never, ever do this. And the reason is the URL is logged in server logs. So somebody could go into that server, and all of your tokens are in plain text just sitting in the logs. You're also exposed in the referrer header. As we showed before, as these redirections are happening, there could be a referrer header somewhere that says the name of a token in it, and then somebody could steal that token. And also, sometimes people aren't so careful about what they copy and paste. Imagine somebody asks a question in Stack Overflow, somebody grabbed the URL to the service, copy and pasted it in there, and that has a token inside of it. That's still valid. Now you've opened up the protected resource to data theft because of that. Now that may happen because people are sometimes careless about what's in the URL, so don't even put it in the URL in the first place, and you won't have to worry about that. What you need to do is like we have done, use the authorization header to pass a bearer token, so that authorization header with a bearer, then a space, then the access token, that is the correct way to pass the token to a protected resource. The only other possible way to do it would be through form parameters over a TLS connection where the form parameters would be encrypted over the wire. But if you can, please use the authorization header. That is the best way to do it. So now that you've seen the code and we've seen some of the vulnerabilities, let's sum up this module so that we can move on to the protected resource.

Summary
So what have we covered in this module? We talked about the client, and we talked about the role that the client plays in the overall OAuth transaction. The client's role is to ask for permission and access a resource on the user's behalf. The client redirects to the authorization server, and once the resource owner is authenticated, they give the client access and permission to access a resource on their behalf. The client then asks for a token and then uses that token to access the data. We saw how to implement a client in Node.js and all of the different pieces that go into it, the authorization, the redirection, validating the token once we grab it, and then using it to pull the data. We also looked at some common client vulnerabilities. Cross-site request forgery was one. In order to fix that, you use the state parameter. The theft of client credentials, so we want to make sure that we keep our credentials safe in Vault or some sort of credential management system. Incorrect redirect URI registration. We need to make sure that we are as specific as possible with our redirect URIs. And on the authorization server side, we want to make sure that we validate exactly, and we'll talk about that again and show you how that's done when we talk about the authorization server in more detail. We could also have a token in the URL parameter. The token is just as valuable as a password, so never, ever put it in a URL parameter because it could be logged, it could be in referrer headers, it could be copied and pasted on the internet somewhere. Instead, use the authorization header with a bearer token in order to complete the process. You have all the tools now, so go build your client. And up next, we'll take a look at the protected resource and how to build one and what its role is in this entire process, so I look forward to seeing you there. Goodbye.

Building the Protected Resource
Introduction
This is Justin Boyer, and welcome back to Understanding OAuth in Node.js. In this module, we're going to be building a protected resource, and we're going to take a look at the code that makes it work and where it fits in the whole process, as well as some vulnerabilities to look out for. To start off, what's the role of the protected resource? It does two things. It verifies the token and gives access to the data. It's the protected resource's job to take the token from the client to validate it and verify that that token is still good. Once it knows that it's good, it parses the token and then gives back the data that the client is requesting. We see here where it fits in our original diagram of our application, and it's very simple, one step, takes the token, returns the resource. So now, let's take a look at the code and see how the protected resource does these important tasks.

Reviewing the Protect Resource Code
Alright, so let's take a look at the code that runs our protected resource. The protected resource is the smallest and simplest piece simply because for our purposes, we only need it to read a token and return a little bit of data. Now your protected resource is usually a full web API, so there could be much more code here. It could become much more complicated, but we kept it simple just for illustrative purposes. We start off with our RSA key. This is the same one we saw with the client. Again, we're going to make sure that the tokens are valid as they come in. We're taking things a little bit differently. We're using Express.js middleware to do our functionality. The reason we do with middleware functions instead of endpoints is so that these middleware functions can be added to any of the endpoints. Remember that the protected resource is just an API. So likely, in a production application, there's going to be several different endpoints that could be hit with the access token from your authorization server; therefore, it makes sense to just have one centralized function that takes care of everything you need to do and pass that in as middleware to each individual endpoint, and it just helps save you from writing the same code over and over again to pull out access tokens and verify them. So you see here, the first function we have is the getAccessToken, and here is the steps to get the access token and where you'll look at them. The first place you'll look is in the authorization header. The authorization header is the best place to put your token. It is the safest place to put your token. And if at all possible, always put your token in an authorization header. We're using a Bearer token here, so we're checking to make sure that that bearer token is there. Now in the HTTP spec, bearer is not case sensitive, so it could be all caps, it could be capital B, it could be all lowercase, so that's why we're making it lowercase here to make sure we cover all of those possibilities. Once we see that authorization header is there, then we take the authorization header after the bearer, which is what the slice function is doing here, and that is the value of our access token. If it's not there, then we check the body, so the body the request, if it's a post request, could give us the access_token, which is acceptable, not as good as the authorization header, but it's actually acceptable because at least the form would be encrypted if it's over TLS. The last place you want to look is the query parameters themselves. Now this is only in the OAuth spec because of edge cases where this is the only possible way to pass through an access token; however, in general, you should never put an access token in a URL. However, because it's in the spec, we've coded for it here. So once we have the token, we have to verify it, and this is very similar to what we saw with the client. We want to make sure that the signature is valid first, so we use that public key to make sure the signature is valid, then we grab the payload, we make sure that the issuer is the authorization server we want, next, we make sure that the Audience is the resource server, which it is, and once we verify that, then we check to make sure that the issued-at date is before now and that the token hasn't expired yet. Once all of these things pass, what we do is we add the access_token to the request object. That way, it'll be passed through to all the other pieces as we move through, and that's really the power of middleware. The request will pass through this function, then we'll have the access token on the backend, and anything that happens after this will automatically have the access_token right there. Then we have another function here, requireAccessToken. This is very simple. But the idea is we have one function to grab the access token and see if it's there and another one to make sure it's there and to respond if it's not. Basically, if the access_token is not there, we're giving back a 401 error, an unauthorized. We have to protect this API, and so this is simply checking to see if the access_token exists, and we know, because we can put this after the first function, that the token has already been validated, so we don't need to validate it again. We just would need to make sure it's there. our actual endpoint is here at gymStats. This is the client's request. It requests the gymStats and does a get. We see here the middleware used, getAccessToken, and then requireAccessToken, and we also have cors here, which cors is for across-domain issues that you might run into if your browser is trying to make a request to a server that's not on the same domain, but then we have our data down below, and this is where the magic happens. So we have our access_token already, and within that access_token, we have our scope, and you'll see what that access_token looks like in more detail when we look at the authorization server code. But the way we've built it is to have the access token have the scope inside of it. The reason for this is so that gymStats API can take the scope and return only the data that the client is authorized to see. That's what all these if statements are doing here. We check to see if each individual scope is there, and if it is, then return the data, if not, we don't return it. That way, if somebody says I don't want my visits to be logged, but it's okay for my membership time and average workout length to be logged, then we won't return the visits. We'll just return membershipTime and averageWorkoutLength. Then we wrap everything up into a JSON object and pass it back. And that is actually it. Again, our API is simple on purpose so that you understand where the protected resource actually fits in all of this. And I will tell you, one more piece that we didn't implement and I'll leave as an exercise for you. One of the ways that we can make sure that our token is valid is to, in the protected resource, do what's called introspection. Introspection is when the protected resource asks the authorization server if this token is still valid. Once we validate that the signature is there, we can still make sure that nothing has been revoked by asking the authorization server. I did not do that here, but that is a possibility. In other words, the protected resource goes to the authorization server and says, hey, I have this token, and I just want to make sure it's still good from your standpoint because, again, the authorization server is the system of record for all of these tokens. So hey, the signature is right, so I know this came from you, but can you just tell me if this has been revoked or if anything else has happened that makes this token invalid? And then the authorization server responds and says, no, this token is valid, and then the resource server will continue in the processing. But that's it for the resource server. It's really just taking the token and making sure it works and then returning the data based on what's inside. So now that you've seen the code, let's take a look at some common vulnerabilities with the protected resource and how we can solve those.

Common Protected Resource Vulnerabilities
Welcome back. And in this clip, we're going to talk about protected resource vulnerabilities. These are the common vulnerabilities you have to watch out for in protected resources and also how to fix them. First up is cross-site scripting, which is a common web API vulnerability. It's when an application places untrusted data into the HTML response. An example of how this may be exploited in a protected resource is imagine a resource that is returning different text based on the language, and you have to pass in a certain language, and it responds with an error message in a language that's not supported? Well, what if that error message spits the input back in? You put in, for example, Chinese, but the API doesn't support Chinese, so instead, it just says, hey, this doesn't support and then whatever the user put in. Again, if this were to be code that the user puts in, then code would execute on the browser, and you have a cross-site scripting error. It's important to validate all of your inputs, HTML encode where necessary, and only put data into the HTML response when it's absolutely necessary to do so, and when you do, encode it. The next vulnerability is called token replay. So this is when a token is stolen through another vulnerability and replayed to the protected resource. There are different ways this could happen. We talked a little bit about it with the client, and we'll talk about it with the authorization server as well, but there are ways to steal the token, maybe through a referrer header or some other means. Somehow an attacker gets ahold of a token and then replays it. One way to fix this is that tokens should have a short expiration date. For example, if your token has a really short expiration date, then all you have to do is give a refresh token to the client. If the token that the client uses has expired, they can simply use a refresh token, send it to the authorization server, and the authorization server will send back a new token to access the protected resource, so the user doesn't have to be involved in that process anymore. After that first time that they've approved it, you can use refresh tokens, and so that eases the user experience on the user side while fixing this vulnerability and making sure that the tokens are expiring fast enough where an attacker won't be able to really use it. Another way to mitigate this is to use TLS with HSTS to enforce TLS on all connections, so HSTS is a security header, it's HTTPS strict transport security, and it tells the browser that it's not allowed to connect without TLS. And this is a good security practice in general, but especially in this case. A protected resource is just a web API at the end of the day, so it could be vulnerable to any of the common web API vulnerabilities we have, so it's good to follow security best practices for web applications, for web APIs because any of those vulnerabilities could possibly be used to steal data from your protected resource. Pluralsight has a Web Application Security learning path. It's here at this URL, and you can use this to learn all you need to know about security risks with web APIs and web applications and how to properly secure them, so take a look at that learning path, and you will be able to secure your protected resource. Now that we've seen the code and talked about some vulnerabilities, let's wrap up this module so that we can get on to the next piece, which is our authorization server.

Summary
So what have we learned in this module? Well, we talked about the protected resource and its role in the entire OAuth ecosystem. The protected resource is the web API the client is accessing. This web API can do any function. It can have any amount of data behind it. What matters is it's being protected by OAuth and requires that token from the authorization server. So we looked at how to implement this in Node.js, we talked about the token using the middleware function in order to strip the token out, add it to the request object, also, we saw how we could validate that token, make sure it's in good working order, we could also optionally ask the authorization server if it's still good, and then once we have the token, we can parse it and use the data inside to return what the client needs. We also took a look at some protected resource vulnerabilities such as cross-site scripting, a token replay, and all the web API vulnerabilities that are out there. Take a look at that Web Application Security learning path to learn all the different vulnerabilities that you could see in a web app, and with that information, you'll be able to secure your protected resource. So you have the tools now. You can go build your protected resource. And come back for the next module because the next one's the big one. It's the authorization server. It's the most complex piece, and I'm going to teach you how to build one.

Building the Authorization Server
Introduction
Hi, this is Justin Boyer, owner of Green Machine Security, and we are going to be building an OAuth authorization server in this module. This is the big one. The authorization server is the most complex piece and has to have the system of record for everything going on in an OAuth transaction. We'll take a look at that. Let's look at the role first. The role of the authorization server is, first, to authenticate. We have to verify the identity of the resource owner. If you remember, the client actually redirects to the authorization server, and the authorization server authenticates the client and then asks, hey, what do you want the client to be able to do? Once the resource owner indicates what the scope the client is allowed to have is, then we have the authentication code created, then the client uses that authentication code, comes back to the authorization server, and gets a token. So the authorization server has to keep track of all of these requests, it has to keep track of the authentication codes and the tokens, and we'll see how all that works when we look at the code. We see how the flow works in our original diagram. The authorization server redirects the employee to the client with an authorization code, the client sends the authorization code to the token endpoint and authenticates using its credentials, and then the authorization server sends a token back to the client, and the client then uses that to gain access to the protected resource. So now we've seen how the authorization server fits into the entire realm of our OAuth transaction. Now it's time for the good stuff. Let's take a look at the code and see how all this stuff works.

Reviewing the Authorization Server Code
Alright, so now we're taking a look at the code for the authorization server. This authorization server is pretty large. There's a lot of stuff that's going on in here, and we're going to take it slow and take it piece by piece. We have our authorization endpoints and token endpoints here. We have our client. So again, our client could be registered dynamically. In our case, it's static, so we actually know who our client is in the first place. We know that it's globomantics-client-1, and we also know the client secret. Again, do not store this in your code in production, never, ever do that. We also have the redirectUris for the client and the scope. Here is the rsaKey that we are using. Notice here that there's an extra value here, this d value. That is the private key, so we have a private key and a public key. The client gets the public key, the protected resource gets the public key, and we have the private key. We use our private key to sign the token, and then the public key is used to verify on the other side. And if you notice these variables here, freshTokens, accessTokens, codes, and requests, this is important. These are serving as kind of our in-memory databases right now, just to keep things simple, so it's very simple and easy to run this application and just have it work. In a production environment, you would be using databases to store this information. But for now, we'll just use these. So we have a helper function here, getClient, again, this is searching our in-memory database. We'll see that we use this quite a bit in order to pull information from a client based on the client_id that's passed in. This is our authorization endpoint, and this is where the client first sends the URL with all of the information we need. So first, we grab the client_id, and we look up that client, and if there's no client, we return an error. Then we validate the redirect_uri. This is important. We want to make sure that the redirect_uris always match in order to make sure that nobody is trying any tricky business by redirecting the application to a malicious website. Next up, we take the scope. So the scope is the scope from the query. We also know what the client.scope is, and were making sure that they are exactly the same. If they're not, again, it's an error. Once we pass all the checks, then we have a request ID. In our case, this is just a random string; however, it could also be the session ID as long as it's unique. We're storing the query of this request in our request object and using the reqid as the key. This is important later on. We'll see where this plays, and it is very important for validation later on. We respond with an approve page. The approve page holds the client information, our reqid in a hidden input field, and our scope. So if you remember our original page, let me show that to you real quick, so here, we have our page. It's asking us, do we want to approve this client, so we have the client ID in there, and we have the redirect URI. Notice this hidden input. This hidden input is actually the reqid that we just saved. Why do you think that is? Well, here's why. When somebody clicks the Approve button, we're going to make sure that that client has a valid request already there. In other words, we don't want somebody just sending data to this authorize endpoint in the hopes of grabbing an author authentication code. We want to make sure that anybody who gets an authentication code has already contacted us and asked for one. For instance, if we have dynamic client registration, which is a good example here, if somebody wanted to come in and say, hey, please register me, we would register them, and then we'd send them to this page once the user is authenticated, and then we'd want to make sure that the guy that just registered with me, is he the one that is sending this request? And that's what we can do. We can put in this hidden field and just make sure, okay, these requests are lined up. Let's see what that looks like in the code. Here is our approve endpoint, and we see that we have a post. So when you click that button, there's a post to /approve. The first thing we do is we pull that reqid, we grab the query and the original query from that reqid in that request object, and then we delete it. We delete it because we don't want anybody following up with that reqid and trying to use it later on, so it's there just until we get that /approve, and then it's deleted. However, the next piece is important. If that query was never there, we return an error. If somebody requests authorization, we say, okay, here is the page to do it. That same person has to come back and match with what we had, so we want to make sure that somebody is not just slamming our endpoint and trying to get an authentication code when there is no clients actually asking for it. Next up, we have the approval, and we have a response type of code, so we're going to grab the scopes from the form and get which ones the resource owner decided to get, and then, again, we're getting the client. We're making sure the scopes line up correctly and there's nothing crazy in there that somebody decided to add. Up next, we create an authorization code. That goes into our codes object, and the codes object will be key with our new code with the query inside, as well as the scope. So that way, the scope that is decided upon by the resource owner is saved in there. We then redirect back to the redirect_uri that the client sent us. But once that happens, the client's going to give us the authorization code again and ask for a token. Here's how that works. First, we take a look at the authorization header. Once we find the authorization header, we then take the client credentials, we take them out of that Base64 encoding, and we store them in-memory. If the authorization header is not there, then we look for the body. Now here is something that's important, we are not doing an either/or here. We're checking the body no matter what. Here's why. We cannot authenticate using multiple methods. In other words, you cannot have an authorization header and in the body at the same time, so we're looking for the authorization header, and then we're making sure that the credentials are not in the authorization header and in the post body. That could indicate a security breach, and that's an error, so returning an error there; otherwise, we're just grabbing the clientId and clientSecret out of the body. And once we have that, we grab the client out of our database, look for it, and then make sure that the clientSecret matches. Alright, so at this point, we know we have a valid client, and now we're taking a look to see, okay, it's an authorization code grant type. There are several different grant types. But for all those others, once you understand the basics of the authorization code grant type, you'll understand those much easier. So I'm sticking with the authorization code as kind of the foundation here. We're going to take the code that's passed in. We're going to look for it in our code object. [00:08: 43.217 ] If we find that code, then we delete it. This is our one-time use policy. Now I'll talk about this when I talk about vulnerabilities, but it's very important to have a one-time use policy. Once your authorization code is used, you burn it, you kill it, and it cannot be used again. Next, we make sure that the clientId from the original request, so remember, we're storing the original query in with that authorization code to make sure that the clientId from the original query matches the current query's clientId to make sure that there is no funny business going on. Once we know that, then we can create our JSON web token, which is what we're using for our tokens, otherwise known as jots. Here, we're creating the JSON web token with a header and our payload. So here's the payload. If you remember, we validated some pieces of this payload in the client and the protected resource. This is where we're actually building it. We have the issuer, the audience is there, we have this, when it was created, as well as the expiration, and then we also have the scope at the bottom, and that is the scope that the resource owner dictated the client is allowed to see. And then this time, instead of verifying, we're going to be signing the access_token, and we will see the access_token here getting signed with our private key that we have from our rsaKey. After that, we save our access tokens. Now this would be put into a database in production, but we're saving our access_token with our clientId, the tokenValue, and the scope. This is for that introspection piece. We talked about it in the last module. If the protected resource wants to ask the authorization server if a token is still valid, this is why we save our access tokens. And we could add another value in here that says whether or not it's been revoked, whether it's still valid, anything you want, any information you need, so that protected resource could then go to the authorization server and say, is this still valid? And then we could search for that access token inside of this database and give the protected resource a response. Next, we generate a refresh token, we add that refresh token into our database, again, to store our refresh token just in case the client asks for a new client using it, and then we create a response. Our response is a JSON object that has an access token. The token type bearer, our scope, and then our refresh token along with it, and that way a client has all the information it needs to then contact the protected resource. Next up is if the grant type is a refresh token. This just means that the client has an expired token, or a token that doesn't work, maybe it's been revoked for some reason, and it wants to create a new token without the user's input, then it sends us a refreshToken and a grant type of refreshToken, it grabs the refreshToken here, and it just creates a brand-new token and sends it along, like we did in the last function. So that's the end of our authorization server. See, it's not as bad as you thought it was going to be, but there is still a lot going on in here. Again, the authorization server is the lifeblood. It's the key to the entire process. It's the system of record for all of these pieces. So it has to generate the authorization code, it has to verify that the client is who they think it is, verify the client, verify the request, verify the state, there are all these different things going on, not to mention being able to sign the token to make sure, to prove that it came from the right authorization server, and then giving that token to the client. So now that we've seen how this all works in code, let's take a look at some common vulnerabilities you can find in authorization servers.

Common Authorization Server Vulnerabilities
Let's take a look at some of the common vulnerabilities you might find in an authorization server. First up, we have session hijacking. This is when the authorization code is passed through a URL, and that URL remains in your browser history when that happens. So imagine somebody at a public library that goes to an OAuth protected resource, and that authorization code is in that browser history. An attacker could then use the authorization code to get an access token for themselves unless you do the fix that we talked about, which is codes being single use only. Do you remember when we looked at that authorization code, when we saw it was a valid one, we burned it immediately? That's how you prevent this from happening. So once somebody accesses the resource, they leave the computer, that authorization code has already been used; therefore, it cannot be used again. Next up, we have redirect URI manipulation. This is when authorization server validates redirect URIs using only the domain. This is called allowing subdirectory or allowing subdomain validation. That's why it's called an OAuth spec. But unfortunately, that opens up security holes when you do that. We talked about this with the client as well that you need to have specific redirect URIs, and you need to make sure that the URIs match exactly. Next up is client impersonation, which is when an attacker steals an authorization code and uses that authorization code with his own redirect URI. Now if the authorization server doesn't verify the redirect URI and gives a token to the attacker, they have access to the protected resource. The way you fix this is when a redirect URI is in the initial request, the authorization server must validate the direct URI sent in the access token request. This is why it's so important for us to, not only have the redirect URIs on file for each client, but also we take that query, we save it in our database, and then we come back to it later on to make sure that everything matches up the way it should. If you don't do this, then the attacker could steal a token by impersonating a client with an authorization code. Like a protected resource, the authorization server is really just a web API, and often, authorization servers could be accessible over the internet; therefore, you have to make sure they're not vulnerable to common web API vulnerabilities, so follow your best practices and take a look at Pluralsight's Web Application Security learning path. That learning path will give you all of the skills you need to protect your authorization server. So let's sum up this whole module and review what we've learned.

Summary
So what have we learned here in this module? We learned about where the authorization server fits in the entire OAuth ecosystem. We learned that the authorization server holds the keys to the entire environment. The authorization server is in charge of keeping track of the authorization codes, of all the tokens, of all the requests, and all the clients, making sure that it knows everything that's currently happening within that system. We saw how to implement this in Node.js, all the different pieces, saving the requests, creating an authorization code, passing that back to the client, and then also creating a token once we validate that the client is who we think it is, and that validation is very important. We saw in our authorization server vulnerabilities about session hijacking, so we have to burn those authorization codes the first time they're used; redirect URI manipulation, we need to make sure that our redirect URIs are exact matching and that they're as specific as possible; our client impersonation, we have to validate that the redirect URIs and the client IDs are the same that was passed in the first request, so the first request comes in, you store that query, and then you come back and make sure that the redirect URI is the same on the both otherwise an attacker could be trying to pass in the client ID with a different redirect URI that's going to his malicious website; and finally, all the web API vulnerabilities out there. I can't list them all, but you can go to Pluralsight's Web Application Security learning path and learn about them yourself. So you have the tools. Now you can go build your authorization server, and in fact, now you have all the pieces you need. You can build yourself a client, you can build yourself the protected resource, and now you can have the authorization server that links them all together, so you are well on your way to building your own OAuth system.